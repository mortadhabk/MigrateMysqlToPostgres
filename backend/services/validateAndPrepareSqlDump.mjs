import fs from 'fs'

/**
 * Validate uploaded SQL dump BEFORE starting Docker.
 * - Rejects PostgreSQL custom dumps (PGDMP)
 * - Rejects binary files (NUL bytes)
 * - Ensures file looks like MySQL SQL dump (basic heuristics)
 * - Extracts DB name if present
 * - Optionally injects CREATE DATABASE + USE when missing
 *
 * Returns: { dbName, warnings: string[] }
 */
export function validateAndPrepareSqlDump(dumpPath, {
  defaultDbName,
  injectUseHeaderIfMissing = true,
  maxPreviewBytes = 256 * 1024, // 256KB is enough for checks
} = {}) {
  if (!fs.existsSync(dumpPath)) {
    throw new Error(`Dump file not found: ${dumpPath}`);
  }

  const buf = fs.readFileSync(dumpPath);
  if (buf.length === 0) {
    throw new Error('Dump file is empty.');
  }

  // 1) Block PostgreSQL custom-format dumps
  const magic5 = buf.slice(0, 5).toString('utf8');
  if (magic5 === 'PGDMP') {
    throw new Error(
      "Invalid file: this is a PostgreSQL custom-format dump (PGDMP). " +
      "Please upload a MySQL text dump generated by mysqldump."
    );
  }

  // 2) Block obvious binary files (NUL bytes)
  if (buf.includes(0)) {
    throw new Error(
      "Invalid file: it looks like a binary dump (contains NUL bytes). " +
      "Please upload a MySQL text dump (.sql) generated by mysqldump."
    );
  }

  // 3) Preview text for quick heuristics (avoid loading huge files as string)
  const preview = buf.slice(0, Math.min(buf.length, maxPreviewBytes)).toString('utf8');

  // Basic "looks like SQL" checks
  const sqlSignals = [
    /CREATE\s+TABLE/i,
    /\bINSERT\s+INTO\b/i,
    /\bDROP\s+TABLE\b/i,
    /\bALTER\s+TABLE\b/i,
    /\bLOCK\s+TABLES\b/i,         // common mysqldump
    /\bUNLOCK\s+TABLES\b/i,       // common mysqldump
    /SET\s+NAMES/i,               // common mysqldump
    /\/\*!\d{5}\s/i               // MySQL versioned comments: /*!40101 SET ... */
  ];
  const hasSqlSignal = sqlSignals.some(re => re.test(preview));

  if (!hasSqlSignal) {
    throw new Error(
      "Invalid file: it doesn't look like a MySQL SQL dump (no CREATE TABLE / INSERT / mysqldump markers found in the beginning of the file)."
    );
  }

  // 4) Extract database name (CREATE DATABASE / USE)
  const warnings = [];
  let dbName = null;

  const createDbMatch = preview.match(/CREATE DATABASE(?:\s+IF NOT EXISTS)?\s+`?([^`;\s]+)`?/i);
  if (createDbMatch?.[1]) dbName = createDbMatch[1];

  if (!dbName) {
    const useDbMatch = preview.match(/^\s*USE\s+`?([^`;\s]+)`?\s*;/im);
    if (useDbMatch?.[1]) dbName = useDbMatch[1];
  }

  // If still missing, fall back
  if (!dbName) {
    dbName = defaultDbName;
    if (!dbName) {
      throw new Error(
        "Unable to determine database name from dump (no CREATE DATABASE / USE found) and no defaultDbName provided."
      );
    }
    warnings.push(`No CREATE DATABASE/USE found. Will use default database: ${dbName}`);

    // 5) Optionally inject header so MySQL import goes into the right DB
    if (injectUseHeaderIfMissing) {
      const header = `CREATE DATABASE IF NOT EXISTS \`${dbName}\`;\nUSE \`${dbName}\`;\n\n`;
      fs.writeFileSync(dumpPath, header + fs.readFileSync(dumpPath, 'utf8'), 'utf8');
      warnings.push(`Injected header: CREATE DATABASE + USE \`${dbName}\``);
    }
  }

  return { dbName, warnings };
}
